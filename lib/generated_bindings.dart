// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Raw bindings to the TurboJpeg API of libjpeg-turbo"
class TurboJpegFFI {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TurboJpegFFI(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TurboJpegFFI.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// MCU block width (in pixels) for a given level of chrominance subsampling.
  /// MCU block sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjMCUWidth =
      _lookup<ffi.Pointer<ffi.Int32>>('tjMCUWidth');

  ffi.Pointer<ffi.Int32> get tjMCUWidth => _tjMCUWidth.value;

  set tjMCUWidth(ffi.Pointer<ffi.Int32> value) => _tjMCUWidth.value = value;

  /// MCU block height (in pixels) for a given level of chrominance subsampling.
  /// MCU block sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjMCUHeight =
      _lookup<ffi.Pointer<ffi.Int32>>('tjMCUHeight');

  ffi.Pointer<ffi.Int32> get tjMCUHeight => _tjMCUHeight.value;

  set tjMCUHeight(ffi.Pointer<ffi.Int32> value) => _tjMCUHeight.value = value;

  /// Red offset (in bytes) for a given pixel format.  This specifies the number
  /// of bytes that the red component is offset from the start of the pixel.  For
  /// instance, if a pixel of format TJ_BGRX is stored in <tt>char pixel[]</tt>,
  /// then the red component will be <tt>pixel[tjRedOffset[TJ_BGRX]]</tt>.  This
  /// will be -1 if the pixel format does not have a red component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjRedOffset =
      _lookup<ffi.Pointer<ffi.Int32>>('tjRedOffset');

  ffi.Pointer<ffi.Int32> get tjRedOffset => _tjRedOffset.value;

  set tjRedOffset(ffi.Pointer<ffi.Int32> value) => _tjRedOffset.value = value;

  /// Green offset (in bytes) for a given pixel format.  This specifies the number
  /// of bytes that the green component is offset from the start of the pixel.
  /// For instance, if a pixel of format TJ_BGRX is stored in
  /// <tt>char pixel[]</tt>, then the green component will be
  /// <tt>pixel[tjGreenOffset[TJ_BGRX]]</tt>.  This will be -1 if the pixel format
  /// does not have a green component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjGreenOffset =
      _lookup<ffi.Pointer<ffi.Int32>>('tjGreenOffset');

  ffi.Pointer<ffi.Int32> get tjGreenOffset => _tjGreenOffset.value;

  set tjGreenOffset(ffi.Pointer<ffi.Int32> value) =>
      _tjGreenOffset.value = value;

  /// Blue offset (in bytes) for a given pixel format.  This specifies the number
  /// of bytes that the Blue component is offset from the start of the pixel.  For
  /// instance, if a pixel of format TJ_BGRX is stored in <tt>char pixel[]</tt>,
  /// then the blue component will be <tt>pixel[tjBlueOffset[TJ_BGRX]]</tt>.  This
  /// will be -1 if the pixel format does not have a blue component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjBlueOffset =
      _lookup<ffi.Pointer<ffi.Int32>>('tjBlueOffset');

  ffi.Pointer<ffi.Int32> get tjBlueOffset => _tjBlueOffset.value;

  set tjBlueOffset(ffi.Pointer<ffi.Int32> value) => _tjBlueOffset.value = value;

  /// Alpha offset (in bytes) for a given pixel format.  This specifies the number
  /// of bytes that the Alpha component is offset from the start of the pixel.
  /// For instance, if a pixel of format TJ_BGRA is stored in
  /// <tt>char pixel[]</tt>, then the alpha component will be
  /// <tt>pixel[tjAlphaOffset[TJ_BGRA]]</tt>.  This will be -1 if the pixel format
  /// does not have an alpha component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjAlphaOffset =
      _lookup<ffi.Pointer<ffi.Int32>>('tjAlphaOffset');

  ffi.Pointer<ffi.Int32> get tjAlphaOffset => _tjAlphaOffset.value;

  set tjAlphaOffset(ffi.Pointer<ffi.Int32> value) =>
      _tjAlphaOffset.value = value;

  /// Pixel size (in bytes) for a given pixel format
  late final ffi.Pointer<ffi.Pointer<ffi.Int32>> _tjPixelSize =
      _lookup<ffi.Pointer<ffi.Int32>>('tjPixelSize');

  ffi.Pointer<ffi.Int32> get tjPixelSize => _tjPixelSize.value;

  set tjPixelSize(ffi.Pointer<ffi.Int32> value) => _tjPixelSize.value = value;

  /// Create a TurboJPEG compressor instance.
  ///
  /// @return a handle to the newly-created instance, or NULL if an error
  /// occurred (see #tjGetErrorStr2().)
  tjhandle tjInitCompress() {
    return _tjInitCompress();
  }

  late final _tjInitCompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitCompress');
  late final _tjInitCompress =
      _tjInitCompressPtr.asFunction<tjhandle Function()>();

  /// Compress an RGB, grayscale, or CMYK image into a JPEG image.
  ///
  /// @param handle a handle to a TurboJPEG compressor or transformer instance
  ///
  /// @param srcBuf pointer to an image buffer containing RGB, grayscale, or
  /// CMYK pixels to be compressed
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per line in the source image.  Normally, this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
  /// <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
  /// is padded to the nearest 32-bit boundary, as is the case for Windows
  /// bitmaps.  You can also be clever and use this parameter to skip lines, etc.
  /// Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param jpegBuf address of a pointer to an image buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer
  /// to accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
  /// for you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tjBufSize().  This should ensure that the buffer never has to be
  /// re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
  /// you should always check <tt>*jpegBuf</tt> upon return from this function, as
  /// it may have changed.
  ///
  /// @param jpegSize pointer to an unsigned long variable that holds the size of
  /// the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
  /// buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
  /// Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
  /// bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
  /// reused from a previous call to one of the JPEG compression functions, then
  /// <tt>*jpegSize</tt> is ignored.
  ///
  /// @param jpegSubsamp the level of chrominance subsampling to be used when
  /// generating the JPEG image (see @ref TJSAMP
  /// "Chrominance subsampling options".)
  ///
  /// @param jpegQual the image quality of the generated JPEG image (1 = worst,
  /// 100 = best)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjCompress2(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> jpegBuf,
    ffi.Pointer<ffi.Uint64> jpegSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompress2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjCompress2');
  late final _tjCompress2 = _tjCompress2Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Uint64>,
          int,
          int,
          int)>();

  /// Compress a YUV planar image into a JPEG image.
  ///
  /// @param handle a handle to a TurboJPEG compressor or transformer instance
  ///
  /// @param srcBuf pointer to an image buffer containing a YUV planar image to be
  /// compressed.  The size of this buffer should match the value returned by
  /// #tjBufSizeYUV2() for the given image width, height, padding, and level of
  /// chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
  /// stored sequentially in the source buffer (refer to @ref YUVnotes
  /// "YUV Image Format Notes".)
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed within TurboJPEG.
  ///
  /// @param pad the line padding used in the source image.  For instance, if each
  /// line in each plane of the YUV image is padded to the nearest multiple of 4
  /// bytes, then <tt>pad</tt> should be set to 4.
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the MCU block height (see #tjMCUHeight), then an
  /// intermediate buffer copy will be performed within TurboJPEG.
  ///
  /// @param subsamp the level of chrominance subsampling used in the source
  /// image (see @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @param jpegBuf address of a pointer to an image buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
  /// for you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tjBufSize().  This should ensure that the buffer never has to be
  /// re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
  /// you should always check <tt>*jpegBuf</tt> upon return from this function, as
  /// it may have changed.
  ///
  /// @param jpegSize pointer to an unsigned long variable that holds the size of
  /// the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
  /// buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
  /// Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
  /// bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
  /// reused from a previous call to one of the JPEG compression functions, then
  /// <tt>*jpegSize</tt> is ignored.
  ///
  /// @param jpegQual the image quality of the generated JPEG image (1 = worst,
  /// 100 = best)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjCompressFromYUV(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pad,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> jpegBuf,
    ffi.Pointer<ffi.Uint64> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUV(
      handle,
      srcBuf,
      width,
      pad,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Int32,
              ffi.Int32)>>('tjCompressFromYUV');
  late final _tjCompressFromYUV = _tjCompressFromYUVPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Uint64>,
          int,
          int)>();

  /// Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image.
  ///
  /// @param handle a handle to a TurboJPEG compressor or transformer instance
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if compressing a grayscale image) that contain a YUV
  /// image to be compressed.  These planes can be contiguous or non-contiguous in
  /// memory.  The size of each plane should match the value returned by
  /// #tjPlaneSizeYUV() for the given image width, height, strides, and level of
  /// chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
  /// for more details.
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed within TurboJPEG.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// line in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
  /// the strides for all planes will be set to their respective plane widths.
  /// You can adjust the strides in order to specify an arbitrary amount of line
  /// padding in each plane or to create a JPEG image from a subregion of a larger
  /// YUV planar image.
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the MCU block height (see #tjMCUHeight), then an
  /// intermediate buffer copy will be performed within TurboJPEG.
  ///
  /// @param subsamp the level of chrominance subsampling used in the source
  /// image (see @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @param jpegBuf address of a pointer to an image buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
  /// for you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tjBufSize().  This should ensure that the buffer never has to be
  /// re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
  /// you should always check <tt>*jpegBuf</tt> upon return from this function, as
  /// it may have changed.
  ///
  /// @param jpegSize pointer to an unsigned long variable that holds the size of
  /// the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
  /// buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
  /// Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
  /// bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
  /// reused from a previous call to one of the JPEG compression functions, then
  /// <tt>*jpegSize</tt> is ignored.
  ///
  /// @param jpegQual the image quality of the generated JPEG image (1 = worst,
  /// 100 = best)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjCompressFromYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> srcPlanes,
    int width,
    ffi.Pointer<ffi.Int32> strides,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> jpegBuf,
    ffi.Pointer<ffi.Uint64> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUVPlanes(
      handle,
      srcPlanes,
      width,
      strides,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int32,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Int32,
              ffi.Int32)>>('tjCompressFromYUVPlanes');
  late final _tjCompressFromYUVPlanes = _tjCompressFromYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          int,
          ffi.Pointer<ffi.Int32>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Uint64>,
          int,
          int)>();

  /// The maximum size of the buffer (in bytes) required to hold a JPEG image with
  /// the given parameters.  The number of bytes returned by this function is
  /// larger than the size of the uncompressed source image.  The reason for this
  /// is that the JPEG format uses 16-bit coefficients, and it is thus possible
  /// for a very high-quality JPEG image with very high-frequency content to
  /// expand rather than compress when converted to the JPEG format.  Such images
  /// represent a very rare corner case, but since there is no way to predict the
  /// size of a JPEG image prior to compression, the corner case has to be
  /// handled.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param jpegSubsamp the level of chrominance subsampling to be used when
  /// generating the JPEG image (see @ref TJSAMP
  /// "Chrominance subsampling options".)
  ///
  /// @return the maximum size of the buffer (in bytes) required to hold the
  /// image, or -1 if the arguments are out of bounds.
  int tjBufSize(
    int width,
    int height,
    int jpegSubsamp,
  ) {
    return _tjBufSize(
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tjBufSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Int32, ffi.Int32, ffi.Int32)>>('tjBufSize');
  late final _tjBufSize =
      _tjBufSizePtr.asFunction<int Function(int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a YUV planar image with
  /// the given parameters.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param pad the width of each line in each plane of the image is padded to
  /// the nearest multiple of this number of bytes (must be a power of 2.)
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the image, or
  /// -1 if the arguments are out of bounds.
  int tjBufSizeYUV2(
    int width,
    int pad,
    int height,
    int subsamp,
  ) {
    return _tjBufSizeYUV2(
      width,
      pad,
      height,
      subsamp,
    );
  }

  late final _tjBufSizeYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>('tjBufSizeYUV2');
  late final _tjBufSizeYUV2 =
      _tjBufSizeYUV2Ptr.asFunction<int Function(int, int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a YUV image plane with
  /// the given parameters.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image.  NOTE: this is the width of
  /// the whole image, not the plane width.
  ///
  /// @param stride bytes per line in the image plane.  Setting this to 0 is the
  /// equivalent of setting it to the plane width.
  ///
  /// @param height height (in pixels) of the YUV image.  NOTE: this is the height
  /// of the whole image, not the plane height.
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the YUV image
  /// plane, or -1 if the arguments are out of bounds.
  int tjPlaneSizeYUV(
    int componentID,
    int width,
    int stride,
    int height,
    int subsamp,
  ) {
    return _tjPlaneSizeYUV(
      componentID,
      width,
      stride,
      height,
      subsamp,
    );
  }

  late final _tjPlaneSizeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32)>>('tjPlaneSizeYUV');
  late final _tjPlaneSizeYUV =
      _tjPlaneSizeYUVPtr.asFunction<int Function(int, int, int, int, int)>();

  /// The plane width of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane width.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane width of a YUV image plane with the given parameters, or
  /// -1 if the arguments are out of bounds.
  int tjPlaneWidth(
    int componentID,
    int width,
    int subsamp,
  ) {
    return _tjPlaneWidth(
      componentID,
      width,
      subsamp,
    );
  }

  late final _tjPlaneWidthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32)>>('tjPlaneWidth');
  late final _tjPlaneWidth =
      _tjPlaneWidthPtr.asFunction<int Function(int, int, int)>();

  /// The plane height of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane height.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param height height (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane height of a YUV image plane with the given parameters, or
  /// -1 if the arguments are out of bounds.
  int tjPlaneHeight(
    int componentID,
    int height,
    int subsamp,
  ) {
    return _tjPlaneHeight(
      componentID,
      height,
      subsamp,
    );
  }

  late final _tjPlaneHeightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Int32, ffi.Int32)>>('tjPlaneHeight');
  late final _tjPlaneHeight =
      _tjPlaneHeightPtr.asFunction<int Function(int, int, int)>();

  /// Encode an RGB or grayscale image into a YUV planar image.  This function
  /// uses the accelerated color conversion routines in the underlying
  /// codec but does not execute any of the other steps in the JPEG compression
  /// process.
  ///
  /// @param handle a handle to a TurboJPEG compressor or transformer instance
  ///
  /// @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
  /// to be encoded
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per line in the source image.  Normally, this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
  /// <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
  /// is padded to the nearest 32-bit boundary, as is the case for Windows
  /// bitmaps.  You can also be clever and use this parameter to skip lines, etc.
  /// Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstBuf pointer to an image buffer that will receive the YUV image.
  /// Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
  /// on the image width, height, padding, and level of chrominance subsampling.
  /// The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the
  /// buffer (refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param pad the width of each line in each plane of the YUV image will be
  /// padded to the nearest multiple of this number of bytes (must be a power of
  /// 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
  /// 4.
  ///
  /// @param subsamp the level of chrominance subsampling to be used when
  /// generating the YUV image (see @ref TJSAMP
  /// "Chrominance subsampling options".)  To generate images suitable for X
  /// Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
  /// image compatible with the I420 (AKA "YUV420P") format.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjEncodeYUV3(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int pad,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV3(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      pad,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjEncodeYUV3');
  late final _tjEncodeYUV3 = _tjEncodeYUV3Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int, int, int, int,
          ffi.Pointer<ffi.Uint8>, int, int, int)>();

  /// Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image
  /// planes.  This function uses the accelerated color conversion routines in the
  /// underlying codec but does not execute any of the other steps in the JPEG
  /// compression process.
  ///
  /// @param handle a handle to a TurboJPEG compressor or transformer instance
  ///
  /// @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
  /// to be encoded
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per line in the source image.  Normally, this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
  /// <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
  /// is padded to the nearest 32-bit boundary, as is the case for Windows
  /// bitmaps.  You can also be clever and use this parameter to skip lines, etc.
  /// Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if generating a grayscale image) that will receive the
  /// encoded image.  These planes can be contiguous or non-contiguous in memory.
  /// Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based
  /// on the image width, height, strides, and level of chrominance subsampling.
  /// Refer to @ref YUVnotes "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// line in the corresponding plane of the output image.  Setting the stride for
  /// any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
  /// the strides for all planes will be set to their respective plane widths.
  /// You can adjust the strides in order to add an arbitrary amount of line
  /// padding to each plane or to encode an RGB or grayscale image into a
  /// subregion of a larger YUV planar image.
  ///
  /// @param subsamp the level of chrominance subsampling to be used when
  /// generating the YUV image (see @ref TJSAMP
  /// "Chrominance subsampling options".)  To generate images suitable for X
  /// Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
  /// image compatible with the I420 (AKA "YUV420P") format.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjEncodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dstPlanes,
    ffi.Pointer<ffi.Int32> strides,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUVPlanes(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstPlanes,
      strides,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32,
              ffi.Int32)>>('tjEncodeYUVPlanes');
  late final _tjEncodeYUVPlanes = _tjEncodeYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int32>,
          int,
          int)>();

  /// Create a TurboJPEG decompressor instance.
  ///
  /// @return a handle to the newly-created instance, or NULL if an error
  /// occurred (see #tjGetErrorStr2().)
  tjhandle tjInitDecompress() {
    return _tjInitDecompress();
  }

  late final _tjInitDecompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitDecompress');
  late final _tjInitDecompress =
      _tjInitDecompressPtr.asFunction<tjhandle Function()>();

  /// Retrieve information about a JPEG image without decompressing it.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param jpegBuf pointer to a buffer containing a JPEG image
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the JPEG image
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the JPEG image
  ///
  /// @param jpegSubsamp pointer to an integer variable that will receive the
  /// level of chrominance subsampling used when the JPEG image was compressed
  /// (see @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @param jpegColorspace pointer to an integer variable that will receive one
  /// of the JPEG colorspace constants, indicating the colorspace of the JPEG
  /// image (see @ref TJCS "JPEG colorspaces".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecompressHeader3(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
    ffi.Pointer<ffi.Int32> jpegSubsamp,
    ffi.Pointer<ffi.Int32> jpegColorspace,
  ) {
    return _tjDecompressHeader3(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
      jpegColorspace,
    );
  }

  late final _tjDecompressHeader3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('tjDecompressHeader3');
  late final _tjDecompressHeader3 = _tjDecompressHeader3Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  /// Returns a list of fractional scaling factors that the JPEG decompressor in
  /// this implementation of TurboJPEG supports.
  ///
  /// @param numscalingfactors pointer to an integer variable that will receive
  /// the number of elements in the list
  ///
  /// @return a pointer to a list of fractional scaling factors, or NULL if an
  /// error is encountered (see #tjGetErrorStr2().)
  ffi.Pointer<tjscalingfactor> tjGetScalingFactors(
    ffi.Pointer<ffi.Int32> numscalingfactors,
  ) {
    return _tjGetScalingFactors(
      numscalingfactors,
    );
  }

  late final _tjGetScalingFactorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tjscalingfactor> Function(
              ffi.Pointer<ffi.Int32>)>>('tjGetScalingFactors');
  late final _tjGetScalingFactors = _tjGetScalingFactorsPtr.asFunction<
      ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int32>)>();

  /// Decompress a JPEG image to an RGB, grayscale, or CMYK image.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param jpegBuf pointer to a buffer containing the JPEG image to decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to an image buffer that will receive the decompressed
  /// image.  This buffer should normally be <tt>pitch * scaledHeight</tt> bytes
  /// in size, where <tt>scaledHeight</tt> can be determined by calling
  /// #TJSCALED() with the JPEG image height and one of the scaling factors
  /// returned by #tjGetScalingFactors().  The <tt>dstBuf</tt> pointer may also be
  /// used to decompress into a specific region of a larger buffer.
  ///
  /// @param width desired width (in pixels) of the destination image.  If this is
  /// different than the width of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired width.  If <tt>width</tt> is
  /// set to 0, then only the height will be considered when determining the
  /// scaled image size.
  ///
  /// @param pitch bytes per line in the destination image.  Normally, this is
  /// <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image
  /// is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt>
  /// if each line of the decompressed image is padded to the nearest 32-bit
  /// boundary, as is the case for Windows bitmaps.  (NOTE: <tt>scaledWidth</tt>
  /// can be determined by calling #TJSCALED() with the JPEG image width and one
  /// of the scaling factors returned by #tjGetScalingFactors().)  You can also be
  /// clever and use the pitch parameter to skip lines, etc.  Setting this
  /// parameter to 0 is the equivalent of setting it to
  /// <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height desired height (in pixels) of the destination image.  If this
  /// is different than the height of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired height.  If <tt>height</tt>
  /// is set to 0, then only the width will be considered when determining the
  /// scaled image size.
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref
  /// TJPF "Pixel formats".)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecompress2(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecompress2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecompress2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjDecompress2');
  late final _tjDecompress2 = _tjDecompress2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, int, int, int, int)>();

  /// Decompress a JPEG image to a YUV planar image.  This function performs JPEG
  /// decompression but leaves out the color conversion step, so a planar YUV
  /// image is generated instead of an RGB image.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param jpegBuf pointer to a buffer containing the JPEG image to decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to an image buffer that will receive the YUV image.
  /// Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
  /// on the image width, height, padding, and level of subsampling.  The Y,
  /// U (Cb), and V (Cr) image planes will be stored sequentially in the buffer
  /// (refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param width desired width (in pixels) of the YUV image.  If this is
  /// different than the width of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired width.  If <tt>width</tt> is
  /// set to 0, then only the height will be considered when determining the
  /// scaled image size.  If the scaled width is not an even multiple of the MCU
  /// block width (see #tjMCUWidth), then an intermediate buffer copy will be
  /// performed within TurboJPEG.
  ///
  /// @param pad the width of each line in each plane of the YUV image will be
  /// padded to the nearest multiple of this number of bytes (must be a power of
  /// 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
  /// 4.
  ///
  /// @param height desired height (in pixels) of the YUV image.  If this is
  /// different than the height of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired height.  If <tt>height</tt>
  /// is set to 0, then only the width will be considered when determining the
  /// scaled image size.  If the scaled height is not an even multiple of the MCU
  /// block height (see #tjMCUHeight), then an intermediate buffer copy will be
  /// performed within TurboJPEG.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecompressToYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int width,
    int pad,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUV2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pad,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjDecompressToYUV2');
  late final _tjDecompressToYUV2 = _tjDecompressToYUV2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, int, int, int)>();

  /// Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image
  /// planes.  This function performs JPEG decompression but leaves out the color
  /// conversion step, so a planar YUV image is generated instead of an RGB image.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param jpegBuf pointer to a buffer containing the JPEG image to decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decompressing a grayscale image) that will receive
  /// the YUV image.  These planes can be contiguous or non-contiguous in memory.
  /// Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based
  /// on the scaled image width, scaled image height, strides, and level of
  /// chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
  /// for more details.
  ///
  /// @param width desired width (in pixels) of the YUV image.  If this is
  /// different than the width of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired width.  If <tt>width</tt> is
  /// set to 0, then only the height will be considered when determining the
  /// scaled image size.  If the scaled width is not an even multiple of the MCU
  /// block width (see #tjMCUWidth), then an intermediate buffer copy will be
  /// performed within TurboJPEG.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// line in the corresponding plane of the output image.  Setting the stride for
  /// any plane to 0 is the same as setting it to the scaled plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
  /// the strides for all planes will be set to their respective scaled plane
  /// widths.  You can adjust the strides in order to add an arbitrary amount of
  /// line padding to each plane or to decompress the JPEG image into a subregion
  /// of a larger YUV planar image.
  ///
  /// @param height desired height (in pixels) of the YUV image.  If this is
  /// different than the height of the JPEG image being decompressed, then
  /// TurboJPEG will use scaling in the JPEG decompressor to generate the largest
  /// possible image that will fit within the desired height.  If <tt>height</tt>
  /// is set to 0, then only the width will be considered when determining the
  /// scaled image size.  If the scaled height is not an even multiple of the MCU
  /// block height (see #tjMCUHeight), then an intermediate buffer copy will be
  /// performed within TurboJPEG.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecompressToYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dstPlanes,
    int width,
    ffi.Pointer<ffi.Int32> strides,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUVPlanes(
      handle,
      jpegBuf,
      jpegSize,
      dstPlanes,
      width,
      strides,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int32,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32,
              ffi.Int32)>>('tjDecompressToYUVPlanes');
  late final _tjDecompressToYUVPlanes = _tjDecompressToYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          int,
          ffi.Pointer<ffi.Int32>,
          int,
          int)>();

  /// Decode a YUV planar image into an RGB or grayscale image.  This function
  /// uses the accelerated color conversion routines in the underlying
  /// codec but does not execute any of the other steps in the JPEG decompression
  /// process.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param srcBuf pointer to an image buffer containing a YUV planar image to be
  /// decoded.  The size of this buffer should match the value returned by
  /// #tjBufSizeYUV2() for the given image width, height, padding, and level of
  /// chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
  /// stored sequentially in the source buffer (refer to @ref YUVnotes
  /// "YUV Image Format Notes".)
  ///
  /// @param pad Use this parameter to specify that the width of each line in each
  /// plane of the YUV source image is padded to the nearest multiple of this
  /// number of bytes (must be a power of 2.)
  ///
  /// @param subsamp the level of chrominance subsampling used in the YUV source
  /// image (see @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @param dstBuf pointer to an image buffer that will receive the decoded
  /// image.  This buffer should normally be <tt>pitch * height</tt> bytes in
  /// size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
  /// specific region of a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per line in the destination image.  Normally, this should
  /// be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
  /// unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
  /// of the destination image should be padded to the nearest 32-bit boundary, as
  /// is the case for Windows bitmaps.  You can also be clever and use the pitch
  /// parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
  /// of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int pad,
    int subsamp,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUV(
      handle,
      srcBuf,
      pad,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjDecodeYUV');
  late final _tjDecodeYUV = _tjDecodeYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int, int,
          ffi.Pointer<ffi.Uint8>, int, int, int, int, int)>();

  /// Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale
  /// image.  This function uses the accelerated color conversion routines in the
  /// underlying codec but does not execute any of the other steps in the JPEG
  /// decompression process.
  ///
  /// @param handle a handle to a TurboJPEG decompressor or transformer instance
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decoding a grayscale image) that contain a YUV image
  /// to be decoded.  These planes can be contiguous or non-contiguous in memory.
  /// The size of each plane should match the value returned by #tjPlaneSizeYUV()
  /// for the given image width, height, strides, and level of chrominance
  /// subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes" for more
  /// details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// line in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
  /// the strides for all planes will be set to their respective plane widths.
  /// You can adjust the strides in order to specify an arbitrary amount of line
  /// padding in each plane or to decode a subregion of a larger YUV planar image.
  ///
  /// @param subsamp the level of chrominance subsampling used in the YUV source
  /// image (see @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @param dstBuf pointer to an image buffer that will receive the decoded
  /// image.  This buffer should normally be <tt>pitch * height</tt> bytes in
  /// size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
  /// specific region of a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per line in the destination image.  Normally, this should
  /// be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
  /// unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
  /// of the destination image should be padded to the nearest 32-bit boundary, as
  /// is the case for Windows bitmaps.  You can also be clever and use the pitch
  /// parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
  /// of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjDecodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> srcPlanes,
    ffi.Pointer<ffi.Int32> strides,
    int subsamp,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUVPlanes(
      handle,
      srcPlanes,
      strides,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjDecodeYUVPlanes');
  late final _tjDecodeYUVPlanes = _tjDecodeYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int32>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int,
          int)>();

  /// Create a new TurboJPEG transformer instance.
  ///
  /// @return a handle to the newly-created instance, or NULL if an error
  /// occurred (see #tjGetErrorStr2().)
  tjhandle tjInitTransform() {
    return _tjInitTransform();
  }

  late final _tjInitTransformPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitTransform');
  late final _tjInitTransform =
      _tjInitTransformPtr.asFunction<tjhandle Function()>();

  /// Losslessly transform a JPEG image into another JPEG image.  Lossless
  /// transforms work by moving the raw DCT coefficients from one JPEG image
  /// structure to another without altering the values of the coefficients.  While
  /// this is typically faster than decompressing the image, transforming it, and
  /// re-compressing it, lossless transforms are not free.  Each lossless
  /// transform requires reading and performing Huffman decoding on all of the
  /// coefficients in the source image, regardless of the size of the destination
  /// image.  Thus, this function provides a means of generating multiple
  /// transformed images from the same source or  applying multiple
  /// transformations simultaneously, in order to eliminate the need to read the
  /// source coefficients multiple times.
  ///
  /// @param handle a handle to a TurboJPEG transformer instance
  ///
  /// @param jpegBuf pointer to a buffer containing the JPEG source image to
  /// transform
  ///
  /// @param jpegSize size of the JPEG source image (in bytes)
  ///
  /// @param n the number of transformed JPEG images to generate
  ///
  /// @param dstBufs pointer to an array of n image buffers.  <tt>dstBufs[i]</tt>
  /// will receive a JPEG image that has been transformed using the parameters in
  /// <tt>transforms[i]</tt>.  TurboJPEG has the ability to reallocate the JPEG
  /// buffer to accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer
  /// for you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tjBufSize() with the transformed or cropped width and height.  Under normal
  /// circumstances, this should ensure that the buffer never has to be
  /// re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)  Note,
  /// however, that there are some rare cases (such as transforming images with a
  /// large amount of embedded EXIF or ICC profile data) in which the output image
  /// will be larger than the worst-case size, and #TJFLAG_NOREALLOC cannot be
  /// used in those cases.
  /// .
  /// If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of
  /// your pre-allocated buffer.  In any case, unless you have set
  /// #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return
  /// from this function, as it may have changed.
  ///
  /// @param dstSizes pointer to an array of n unsigned long variables that will
  /// receive the actual sizes (in bytes) of each transformed JPEG image.  If
  /// <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then
  /// <tt>dstSizes[i]</tt> should be set to the size of the buffer.  Upon return,
  /// <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)
  ///
  /// @param transforms pointer to an array of n #tjtransform structures, each of
  /// which specifies the transform parameters and/or cropping region for the
  /// corresponding transformed output image.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  /// "flags"
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  /// and #tjGetErrorCode().)
  int tjTransform(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    int n,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dstBufs,
    ffi.Pointer<ffi.Uint64> dstSizes,
    ffi.Pointer<tjtransform> transforms,
    int flags,
  ) {
    return _tjTransform(
      handle,
      jpegBuf,
      jpegSize,
      n,
      dstBufs,
      dstSizes,
      transforms,
      flags,
    );
  }

  late final _tjTransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<tjtransform>,
              ffi.Int32)>>('tjTransform');
  late final _tjTransform = _tjTransformPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<tjtransform>,
          int)>();

  /// Destroy a TurboJPEG compressor, decompressor, or transformer instance.
  ///
  /// @param handle a handle to a TurboJPEG compressor, decompressor or
  /// transformer instance
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)
  int tjDestroy(
    tjhandle handle,
  ) {
    return _tjDestroy(
      handle,
    );
  }

  late final _tjDestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(tjhandle)>>('tjDestroy');
  late final _tjDestroy = _tjDestroyPtr.asFunction<int Function(tjhandle)>();

  /// Allocate an image buffer for use with TurboJPEG.  You should always use
  /// this function to allocate the JPEG destination buffer(s) for the compression
  /// and transform functions unless you are disabling automatic buffer
  /// (re)allocation (by setting #TJFLAG_NOREALLOC.)
  ///
  /// @param bytes the number of bytes to allocate
  ///
  /// @return a pointer to a newly-allocated buffer with the specified number of
  /// bytes.
  ///
  /// @sa tjFree()
  ffi.Pointer<ffi.Uint8> tjAlloc(
    int bytes,
  ) {
    return _tjAlloc(
      bytes,
    );
  }

  late final _tjAllocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.Int32)>>(
          'tjAlloc');
  late final _tjAlloc =
      _tjAllocPtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  /// Load an uncompressed image from disk into memory.
  ///
  /// @param filename name of a file containing an uncompressed image in Windows
  /// BMP or PBMPLUS (PPM/PGM) format
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the uncompressed image
  ///
  /// @param align row alignment of the image buffer to be returned (must be a
  /// power of 2.)  For instance, setting this parameter to 4 will cause all rows
  /// in the image buffer to be padded to the nearest 32-bit boundary, and setting
  /// this parameter to 1 will cause all rows in the image buffer to be unpadded.
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the uncompressed image
  ///
  /// @param pixelFormat pointer to an integer variable that specifies or will
  /// receive the pixel format of the uncompressed image buffer.  The behavior of
  /// #tjLoadImage() will vary depending on the value of <tt>*pixelFormat</tt>
  /// passed to the function:
  /// - @ref TJPF_UNKNOWN : The uncompressed image buffer returned by the function
  /// will use the most optimal pixel format for the file type, and
  /// <tt>*pixelFormat</tt> will contain the ID of this pixel format upon
  /// successful return from the function.
  /// - @ref TJPF_GRAY : Only PGM files and 8-bit BMP files with a grayscale
  /// colormap can be loaded.
  /// - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  /// converted using a quick & dirty algorithm that is suitable only for testing
  /// purposes (proper conversion between CMYK and other formats requires a color
  /// management system.)
  /// - Other @ref TJPF "pixel formats" : The uncompressed image buffer will use
  /// the specified pixel format, and pixel format conversion will be performed if
  /// necessary.
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  /// "flags".
  ///
  /// @return a pointer to a newly-allocated buffer containing the uncompressed
  /// image, converted to the chosen pixel format and with the chosen row
  /// alignment, or NULL if an error occurred (see #tjGetErrorStr2().)  This
  /// buffer should be freed using #tjFree().
  ffi.Pointer<ffi.Uint8> tjLoadImage(
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Int32> width,
    int align,
    ffi.Pointer<ffi.Int32> height,
    ffi.Pointer<ffi.Int32> pixelFormat,
    int flags,
  ) {
    return _tjLoadImage(
      filename,
      width,
      align,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjLoadImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Int32)>>('tjLoadImage');
  late final _tjLoadImage = _tjLoadImagePtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int32>,
          int,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          int)>();

  /// Save an uncompressed image from memory to disk.
  ///
  /// @param filename name of a file to which to save the uncompressed image.
  /// The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format,
  /// depending on the file extension.
  ///
  /// @param buffer pointer to an image buffer containing RGB, grayscale, or
  /// CMYK pixels to be saved
  ///
  /// @param width width (in pixels) of the uncompressed image
  ///
  /// @param pitch bytes per line in the image buffer.  Setting this parameter to
  /// 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the uncompressed image
  ///
  /// @param pixelFormat pixel format of the image buffer (see @ref TJPF
  /// "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
  /// image will be stored in PGM or 8-bit (indexed color) BMP format.  Otherwise,
  /// the image will be stored in PPM or 24-bit BMP format.  If this parameter
  /// is set to @ref TJPF_CMYK, then the CMYK pixels will be converted to RGB
  /// using a quick & dirty algorithm that is suitable only for testing (proper
  /// conversion between CMYK and other formats requires a color management
  /// system.)
  ///
  /// @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  /// "flags".
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)
  int tjSaveImage(
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Uint8> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjSaveImage(
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjSaveImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjSaveImage');
  late final _tjSaveImage = _tjSaveImagePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Uint8>, int, int, int,
          int, int)>();

  /// Free an image buffer previously allocated by TurboJPEG.  You should always
  /// use this function to free JPEG destination buffer(s) that were automatically
  /// (re)allocated by the compression and transform functions or that were
  /// manually allocated using #tjAlloc().
  ///
  /// @param buffer address of the buffer to free.  If the address is NULL, then
  /// this function has no effect.
  ///
  /// @sa tjAlloc()
  void tjFree(
    ffi.Pointer<ffi.Uint8> buffer,
  ) {
    return _tjFree(
      buffer,
    );
  }

  late final _tjFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint8>)>>(
          'tjFree');
  late final _tjFree =
      _tjFreePtr.asFunction<void Function(ffi.Pointer<ffi.Uint8>)>();

  /// Returns a descriptive error message explaining why the last command failed.
  ///
  /// @param handle a handle to a TurboJPEG compressor, decompressor, or
  /// transformer instance, or NULL if the error was generated by a global
  /// function (but note that retrieving the error message for a global function
  /// is thread-safe only on platforms that support thread-local storage.)
  ///
  /// @return a descriptive error message explaining why the last command failed.
  ffi.Pointer<ffi.Int8> tjGetErrorStr2(
    tjhandle handle,
  ) {
    return _tjGetErrorStr2(
      handle,
    );
  }

  late final _tjGetErrorStr2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(tjhandle)>>(
          'tjGetErrorStr2');
  late final _tjGetErrorStr2 =
      _tjGetErrorStr2Ptr.asFunction<ffi.Pointer<ffi.Int8> Function(tjhandle)>();

  /// Returns a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  ///
  /// @param handle a handle to a TurboJPEG compressor, decompressor or
  /// transformer instance
  ///
  /// @return a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  int tjGetErrorCode(
    tjhandle handle,
  ) {
    return _tjGetErrorCode(
      handle,
    );
  }

  late final _tjGetErrorCodePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(tjhandle)>>(
          'tjGetErrorCode');
  late final _tjGetErrorCode =
      _tjGetErrorCodePtr.asFunction<int Function(tjhandle)>();

  int TJBUFSIZE(
    int width,
    int height,
  ) {
    return _TJBUFSIZE(
      width,
      height,
    );
  }

  late final _TJBUFSIZEPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Int32, ffi.Int32)>>(
          'TJBUFSIZE');
  late final _TJBUFSIZE = _TJBUFSIZEPtr.asFunction<int Function(int, int)>();

  int TJBUFSIZEYUV(
    int width,
    int height,
    int jpegSubsamp,
  ) {
    return _TJBUFSIZEYUV(
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _TJBUFSIZEYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Int32, ffi.Int32, ffi.Int32)>>('TJBUFSIZEYUV');
  late final _TJBUFSIZEYUV =
      _TJBUFSIZEYUVPtr.asFunction<int Function(int, int, int)>();

  int tjBufSizeYUV(
    int width,
    int height,
    int subsamp,
  ) {
    return _tjBufSizeYUV(
      width,
      height,
      subsamp,
    );
  }

  late final _tjBufSizeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Int32, ffi.Int32, ffi.Int32)>>('tjBufSizeYUV');
  late final _tjBufSizeYUV =
      _tjBufSizeYUVPtr.asFunction<int Function(int, int, int)>();

  int tjCompress(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    ffi.Pointer<ffi.Uint64> compressedSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      compressedSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjCompress');
  late final _tjCompress = _tjCompressPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int, int, int, int,
          ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint64>, int, int, int)>();

  int tjEncodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32)>>('tjEncodeYUV');
  late final _tjEncodeYUV = _tjEncodeYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int, int, int, int,
          ffi.Pointer<ffi.Uint8>, int, int)>();

  int tjEncodeYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32)>>('tjEncodeYUV2');
  late final _tjEncodeYUV2 = _tjEncodeYUV2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int, int, int, int,
          ffi.Pointer<ffi.Uint8>, int, int)>();

  int tjDecompressHeader(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
  ) {
    return _tjDecompressHeader(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
    );
  }

  late final _tjDecompressHeaderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('tjDecompressHeader');
  late final _tjDecompressHeader = _tjDecompressHeaderPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  int tjDecompressHeader2(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
    ffi.Pointer<ffi.Int32> jpegSubsamp,
  ) {
    return _tjDecompressHeader2(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tjDecompressHeader2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('tjDecompressHeader2');
  late final _tjDecompressHeader2 = _tjDecompressHeader2Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>)>();

  int tjDecompress(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    int flags,
  ) {
    return _tjDecompress(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelSize,
      flags,
    );
  }

  late final _tjDecompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              tjhandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('tjDecompress');
  late final _tjDecompress = _tjDecompressPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, int, int, int, int)>();

  int tjDecompressToYUV(
    tjhandle handle,
    ffi.Pointer<ffi.Uint8> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Uint8> dstBuf,
    int flags,
  ) {
    return _tjDecompressToYUV(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      flags,
    );
  }

  late final _tjDecompressToYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(tjhandle, ffi.Pointer<ffi.Uint8>, ffi.Uint64,
              ffi.Pointer<ffi.Uint8>, ffi.Int32)>>('tjDecompressToYUV');
  late final _tjDecompressToYUV = _tjDecompressToYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<ffi.Int8> tjGetErrorStr() {
    return _tjGetErrorStr();
  }

  late final _tjGetErrorStrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function()>>(
          'tjGetErrorStr');
  late final _tjGetErrorStr =
      _tjGetErrorStrPtr.asFunction<ffi.Pointer<ffi.Int8> Function()>();
}

/// Chrominance subsampling options.
/// When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK
/// to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of
/// the Cb and Cr (chrominance) components can be discarded or averaged together
/// to produce a smaller image with little perceptible loss of image clarity
/// (the human eye is more sensitive to small changes in brightness than to
/// small changes in color.)  This is called "chrominance subsampling".
abstract class TJSAMP {
  /// 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or
  /// YUV image will contain one chrominance component for every pixel in the
  /// source image.
  static const int TJSAMP_444 = 0;

  /// 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 2x1 block of pixels in the source image.
  static const int TJSAMP_422 = 1;

  /// 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 2x2 block of pixels in the source image.
  static const int TJSAMP_420 = 2;

  /// Grayscale.  The JPEG or YUV image will contain no chrominance components.
  static const int TJSAMP_GRAY = 3;

  /// 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 1x2 block of pixels in the source image.
  ///
  /// @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
  static const int TJSAMP_440 = 4;

  /// 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 4x1 block of pixels in the source image.
  /// JPEG images compressed with 4:1:1 subsampling will be almost exactly the
  /// same size as those compressed with 4:2:0 subsampling, and in the
  /// aggregate, both subsampling methods produce approximately the same
  /// perceptual quality.  However, 4:1:1 is better able to reproduce sharp
  /// horizontal features.
  ///
  /// @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.
  static const int TJSAMP_411 = 5;
}

/// Pixel formats
abstract class TJPF {
  /// RGB pixel format.  The red, green, and blue components in the image are
  /// stored in 3-byte pixels in the order R, G, B from lowest to highest byte
  /// address within each pixel.
  static const int TJPF_RGB = 0;

  /// BGR pixel format.  The red, green, and blue components in the image are
  /// stored in 3-byte pixels in the order B, G, R from lowest to highest byte
  /// address within each pixel.
  static const int TJPF_BGR = 1;

  /// RGBX pixel format.  The red, green, and blue components in the image are
  /// stored in 4-byte pixels in the order R, G, B from lowest to highest byte
  /// address within each pixel.  The X component is ignored when compressing
  /// and undefined when decompressing.
  static const int TJPF_RGBX = 2;

  /// BGRX pixel format.  The red, green, and blue components in the image are
  /// stored in 4-byte pixels in the order B, G, R from lowest to highest byte
  /// address within each pixel.  The X component is ignored when compressing
  /// and undefined when decompressing.
  static const int TJPF_BGRX = 3;

  /// XBGR pixel format.  The red, green, and blue components in the image are
  /// stored in 4-byte pixels in the order R, G, B from highest to lowest byte
  /// address within each pixel.  The X component is ignored when compressing
  /// and undefined when decompressing.
  static const int TJPF_XBGR = 4;

  /// XRGB pixel format.  The red, green, and blue components in the image are
  /// stored in 4-byte pixels in the order B, G, R from highest to lowest byte
  /// address within each pixel.  The X component is ignored when compressing
  /// and undefined when decompressing.
  static const int TJPF_XRGB = 5;

  /// Grayscale pixel format.  Each 1-byte pixel represents a luminance
  /// (brightness) level from 0 to 255.
  static const int TJPF_GRAY = 6;

  /// RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when
  /// decompressing, the X component is guaranteed to be 0xFF, which can be
  /// interpreted as an opaque alpha channel.
  static const int TJPF_RGBA = 7;

  /// BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when
  /// decompressing, the X component is guaranteed to be 0xFF, which can be
  /// interpreted as an opaque alpha channel.
  static const int TJPF_BGRA = 8;

  /// ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when
  /// decompressing, the X component is guaranteed to be 0xFF, which can be
  /// interpreted as an opaque alpha channel.
  static const int TJPF_ABGR = 9;

  /// ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when
  /// decompressing, the X component is guaranteed to be 0xFF, which can be
  /// interpreted as an opaque alpha channel.
  static const int TJPF_ARGB = 10;

  /// CMYK pixel format.  Unlike RGB, which is an additive color model used
  /// primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
  /// color model used primarily for printing.  In the CMYK color model, the
  /// value of each color component typically corresponds to an amount of cyan,
  /// magenta, yellow, or black ink that is applied to a white background.  In
  /// order to convert between CMYK and RGB, it is necessary to use a color
  /// management system (CMS.)  A CMS will attempt to map colors within the
  /// printer's gamut to perceptually similar colors in the display's gamut and
  /// vice versa, but the mapping is typically not 1:1 or reversible, nor can it
  /// be defined with a simple formula.  Thus, such a conversion is out of scope
  /// for a codec library.  However, the TurboJPEG API allows for compressing
  /// CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK
  /// JPEG images into CMYK pixels.
  static const int TJPF_CMYK = 11;

  /// Unknown pixel format.  Currently this is only used by #tjLoadImage().
  static const int TJPF_UNKNOWN = -1;
}

/// JPEG colorspaces
abstract class TJCS {
  /// RGB colorspace.  When compressing the JPEG image, the R, G, and B
  /// components in the source image are reordered into image planes, but no
  /// colorspace conversion or subsampling is performed.  RGB JPEG images can be
  /// decompressed to any of the extended RGB pixel formats or grayscale, but
  /// they cannot be decompressed to YUV images.
  static const int TJCS_RGB = 0;

  /// YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a
  /// mathematical transformation of RGB designed solely for storage and
  /// transmission.  YCbCr images must be converted to RGB before they can
  /// actually be displayed.  In the YCbCr colorspace, the Y (luminance)
  /// component represents the black & white portion of the original image, and
  /// the Cb and Cr (chrominance) components represent the color portion of the
  /// original image.  Originally, the analog equivalent of this transformation
  /// allowed the same signal to drive both black & white and color televisions,
  /// but JPEG images use YCbCr primarily because it allows the color data to be
  /// optionally subsampled for the purposes of reducing bandwidth or disk
  /// space.  YCbCr is the most common JPEG colorspace, and YCbCr JPEG images
  /// can be compressed from and decompressed to any of the extended RGB pixel
  /// formats or grayscale, or they can be decompressed to YUV planar images.
  static const int TJCS_YCbCr = 1;

  /// Grayscale colorspace.  The JPEG image retains only the luminance data (Y
  /// component), and any color data from the source image is discarded.
  /// Grayscale JPEG images can be compressed from and decompressed to any of
  /// the extended RGB pixel formats or grayscale, or they can be decompressed
  /// to YUV planar images.
  static const int TJCS_GRAY = 2;

  /// CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
  /// components in the source image are reordered into image planes, but no
  /// colorspace conversion or subsampling is performed.  CMYK JPEG images can
  /// only be decompressed to CMYK pixels.
  static const int TJCS_CMYK = 3;

  /// YCCK colorspace.  YCCK (AKA "YCbCrK") is not an absolute colorspace but
  /// rather a mathematical transformation of CMYK designed solely for storage
  /// and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be
  /// reversibly transformed into YCCK, and as with YCbCr, the chrominance
  /// components in the YCCK pixels can be subsampled without incurring major
  /// perceptual loss.  YCCK JPEG images can only be compressed from and
  /// decompressed to CMYK pixels.
  static const int TJCS_YCCK = 4;
}

/// Error codes
abstract class TJERR {
  /// The error was non-fatal and recoverable, but the image may still be
  /// corrupt.
  static const int TJERR_WARNING = 0;

  /// The error was fatal and non-recoverable.
  static const int TJERR_FATAL = 1;
}

/// Transform operations for #tjTransform()
abstract class TJXOP {
  /// Do not transform the position of the image pixels
  static const int TJXOP_NONE = 0;

  /// Flip (mirror) image horizontally.  This transform is imperfect if there
  /// are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)
  static const int TJXOP_HFLIP = 1;

  /// Flip (mirror) image vertically.  This transform is imperfect if there are
  /// any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)
  static const int TJXOP_VFLIP = 2;

  /// Transpose image (flip/mirror along upper left to lower right axis.)  This
  /// transform is always perfect.
  static const int TJXOP_TRANSPOSE = 3;

  /// Transverse transpose image (flip/mirror along upper right to lower left
  /// axis.)  This transform is imperfect if there are any partial MCU blocks in
  /// the image (see #TJXOPT_PERFECT.)
  static const int TJXOP_TRANSVERSE = 4;

  /// Rotate image clockwise by 90 degrees.  This transform is imperfect if
  /// there are any partial MCU blocks on the bottom edge (see
  /// #TJXOPT_PERFECT.)
  static const int TJXOP_ROT90 = 5;

  /// Rotate image 180 degrees.  This transform is imperfect if there are any
  /// partial MCU blocks in the image (see #TJXOPT_PERFECT.)
  static const int TJXOP_ROT180 = 6;

  /// Rotate image counter-clockwise by 90 degrees.  This transform is imperfect
  /// if there are any partial MCU blocks on the right edge (see
  /// #TJXOPT_PERFECT.)
  static const int TJXOP_ROT270 = 7;
}

/// Scaling factor
class tjscalingfactor extends ffi.Struct {
  /// Numerator
  @ffi.Int32()
  external int num;

  /// Denominator
  @ffi.Int32()
  external int denom;
}

/// Cropping region
class tjregion extends ffi.Struct {
  /// The left boundary of the cropping region.  This must be evenly divisible
  /// by the MCU block width (see #tjMCUWidth.)
  @ffi.Int32()
  external int x;

  /// The upper boundary of the cropping region.  This must be evenly divisible
  /// by the MCU block height (see #tjMCUHeight.)
  @ffi.Int32()
  external int y;

  /// The width of the cropping region. Setting this to 0 is the equivalent of
  /// setting it to the width of the source JPEG image - x.
  @ffi.Int32()
  external int w;

  /// The height of the cropping region. Setting this to 0 is the equivalent of
  /// setting it to the height of the source JPEG image - y.
  @ffi.Int32()
  external int h;
}

/// Lossless transform
class tjtransform extends ffi.Struct {
  /// Cropping region
  external tjregion r;

  /// One of the @ref TJXOP "transform operations"
  @ffi.Int32()
  external int op;

  /// The bitwise OR of one of more of the @ref TJXOPT_CROP "transform options"
  @ffi.Int32()
  external int options;

  /// Arbitrary data that can be accessed within the body of the callback
  /// function
  external ffi.Pointer<ffi.Void> data;

  /// A callback function that can be used to modify the DCT coefficients
  /// after they are losslessly transformed but before they are transcoded to a
  /// new JPEG image.  This allows for custom filters or other transformations
  /// to be applied in the frequency domain.
  ///
  /// @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:
  /// this pointer is not guaranteed to be valid once the callback returns, so
  /// applications wishing to hand off the DCT coefficients to another function
  /// or library should make a copy of them within the body of the callback.)
  ///
  /// @param arrayRegion #tjregion structure containing the width and height of
  /// the array pointed to by <tt>coeffs</tt> as well as its offset relative to
  /// the component plane.  TurboJPEG implementations may choose to split each
  /// component plane into multiple DCT coefficient arrays and call the callback
  /// function once for each array.
  ///
  /// @param planeRegion #tjregion structure containing the width and height of
  /// the component plane to which <tt>coeffs</tt> belongs
  ///
  /// @param componentID ID number of the component plane to which
  /// <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,
  /// and 2 in typical JPEG images.)
  ///
  /// @param transformID ID number of the transformed image to which
  /// <tt>coeffs</tt> belongs.  This is the same as the index of the transform
  /// in the <tt>transforms</tt> array that was passed to #tjTransform().
  ///
  /// @param transform a pointer to a #tjtransform structure that specifies the
  /// parameters and/or cropping region for this transform
  ///
  /// @return 0 if the callback was successful, or -1 if an error occurred.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int16>, tjregion, tjregion,
              ffi.Int32, ffi.Int32, ffi.Pointer<tjtransform>)>> customFilter;
}

/// TurboJPEG instance handle
typedef tjhandle = ffi.Pointer<ffi.Void>;

const int TJ_NUMSAMP = 6;

const int TJ_NUMPF = 12;

const int TJ_NUMCS = 5;

const int TJFLAG_BOTTOMUP = 2;

const int TJFLAG_FASTUPSAMPLE = 256;

const int TJFLAG_NOREALLOC = 1024;

const int TJFLAG_FASTDCT = 2048;

const int TJFLAG_ACCURATEDCT = 4096;

const int TJFLAG_STOPONWARNING = 8192;

const int TJFLAG_PROGRESSIVE = 16384;

const int TJFLAG_LIMITSCANS = 32768;

const int TJ_NUMERR = 2;

const int TJ_NUMXOP = 8;

const int TJXOPT_PERFECT = 1;

const int TJXOPT_TRIM = 2;

const int TJXOPT_CROP = 4;

const int TJXOPT_GRAY = 8;

const int TJXOPT_NOOUTPUT = 16;

const int TJXOPT_PROGRESSIVE = 32;

const int TJXOPT_COPYNONE = 64;

const int TJFLAG_FORCEMMX = 8;

const int TJFLAG_FORCESSE = 16;

const int TJFLAG_FORCESSE2 = 32;

const int TJFLAG_FORCESSE3 = 128;

const int NUMSUBOPT = 6;

const int TJ_444 = 0;

const int TJ_422 = 1;

const int TJ_420 = 2;

const int TJ_411 = 2;

const int TJ_GRAYSCALE = 3;

const int TJ_BGR = 1;

const int TJ_BOTTOMUP = 2;

const int TJ_FORCEMMX = 8;

const int TJ_FORCESSE = 16;

const int TJ_FORCESSE2 = 32;

const int TJ_ALPHAFIRST = 64;

const int TJ_FORCESSE3 = 128;

const int TJ_FASTUPSAMPLE = 256;

const int TJ_YUV = 512;
